{"version":3,"sources":["js/states/GameState.js"],"names":["create","NUM_ROWS","NUM_COLS","NUM_CIRCLES","BLOCK_SIZE","SCALE_CIRCLE","GRID_WIDTH","GRID_START_X","GRID_START_Y","GRID_END_X","GRID_END_Y","frame","Phaser","Rectangle","rect","gridMatrix","i","push","j","circlesLeft","style","font","fill","game","add","text","circleScore","refreshStats","drawGrid","drawCircles","result","update","grid","graphics","lineStyle","drawRect","generateTexture","circles","group","enableBody","circle","centerX","centerY","inputEnabled","input","enableDrag","anchor","setTo","scale","body","collideWorldBounds","moved","events","onDragStart","onDragStop","sprite","console","log","pointerDragged","tempXY","x","y","tempCoord","getCoord","Error","key","coord","seeGrid","occupied","snapToGrid","resetCircle","position","Math","floor","counter","gridString","headers","length","contains","justAClick","distanceFromLastUp","distance","activePointer","positionDown"],"mappings":"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","file":"GameState.c607a544.map","sourceRoot":"..","sourcesContent":["\"use strict\"; // let's capture all errors\n\n//this game will have only 1 state\nexport default {\n\n\t//executed after everything is loaded\n\tcreate: function () {\n\n\t\t// Let's set a number of constants, so they can be changed later\n\t\tthis.NUM_ROWS = 13;\n\t\tthis.NUM_COLS = 13;\n\t\tthis.NUM_CIRCLES = 13;\n\t\tthis.BLOCK_SIZE = 20;\n\t\tthis.SCALE_CIRCLE = this.BLOCK_SIZE / 85 * 0.6;\n\t\tthis.GRID_WIDTH = 1;\n\t\tthis.GRID_START_X = 40;\n\t\tthis.GRID_START_Y = 40;\n\t\tthis.GRID_END_X = this.NUM_COLS * this.BLOCK_SIZE;\n\t\tthis.GRID_END_Y = this.NUM_ROWS * this.BLOCK_SIZE;\n\n\t\t// create a Rectangle frame around grid (invisible)\n\t\tthis.frame = new Phaser.Rectangle(this.GRID_START_X, this.GRID_START_Y, this.GRID_END_X, this.GRID_END_Y);\n\n\t\t// Array for rectangles in grid\n\t\tthis.rect = [];\n\n\t\t// matrix for grid, initialise with zeroes\n\t\tthis.gridMatrix = [];\n\t\tfor (var i = 0; i < this.NUM_COLS; i++) { // create an array per column\n\t\t\tthis.gridMatrix.push([]);\n\t\t\tfor (var j = 0; j < this.NUM_ROWS; j++) {\n\t\t\t\tthis.gridMatrix[i].push(0); // fill each column with zeroes\n\t\t\t}\n\t\t}\n\t\t// initialise circle counter\n\t\tthis.circlesLeft = this.NUM_CIRCLES;\n\n\t\tvar style = { font: '15px Arial', fill: '#000' };\n\t\tthis.game.add.text(350, 40, 'Drag all the circles from the centre\\nand place them anywhere on the grid. ', style);\n\t\tthis.game.add.text(350, 100, 'Circles left: ', style);\n\n\t\tstyle = { font: '25px Arial', fill: '#0d50bc' };\n\t\tthis.circleScore = this.game.add.text(450, 95, '', style);\n\n\t\tthis.refreshStats(0);\n\n\t\t// draw the grid\n\t\tthis.drawGrid();\n\n\t\t// draw the circles\n\t\tthis.drawCircles();\n\n\t\t// debugging\n\t\tthis.result = '';\n\t},\n\n\tupdate: function () {\n\t\t//      this.refreshStats(0);\n\t},\n\n\t// draw grid\n\tdrawGrid: function () {\n\n\t\tthis.grid = game.add.graphics(this.GRID_START_X, this.GRID_START_Y);\n\t\tthis.grid.lineStyle(this.GRID_WIDTH, '#000', 1);\n\t\t//       this.grid.boundsPadding = 0; // from default of 10\n\n\t\t/* draw the grid with graphics, Rows * Cols number of rectangles\n\t\talso create invisible rectangles of the same size on top of each (for snap to grid)\n\t\t*/\n\t\tfor (var i = 0; i < this.NUM_COLS; i++) {\n\t\t\tfor (var j = 0; j < this.NUM_ROWS; j++) {\n\t\t\t\tthis.grid.drawRect((i * this.BLOCK_SIZE), (j * this.BLOCK_SIZE), this.BLOCK_SIZE, this.BLOCK_SIZE);\n\t\t\t\tthis.rect.push(new Phaser.Rectangle(this.GRID_START_X + (i * this.BLOCK_SIZE), this.GRID_START_Y +\n\t\t\t\t\t(j * this.BLOCK_SIZE), this.BLOCK_SIZE, this.BLOCK_SIZE));\n\t\t\t}\n\t\t}\n\t\tthis.grid.generateTexture(); // change graphics into texture to increase performance\n\n\t},\n\n\tdrawCircles: function () {\n\t\t// draw circles in the centre of the grid, first move graphics pointer to the centre\n\n\t\tthis.circles = game.add.group(); // group for all circles\n\t\tthis.circles.enableBody = true;\n\t\tfor (var i = 0; i < this.NUM_CIRCLES; i++) {\n\t\t\tthis.circle = this.circles.create(this.frame.centerX, this.frame.centerY, 'circle');\n\t\t\tthis.circle.inputEnabled = true;\n\t\t\t//circle.pixelPerfectClick = true;\n\t\t\tthis.circle.input.enableDrag(true, true, true, '255', this.frame);\n\t\t\tthis.circle.anchor.setTo(0.5);\n\t\t\tthis.circle.scale.setTo(this.SCALE_CIRCLE);\n\t\t\tthis.circle.body.collideWorldBounds = true;\n\t\t\tthis.circle.moved = false;\n\t\t\tthis.circle.events.onDragStart.add(this.onDragStart, this);\n\t\t\tthis.circle.events.onDragStop.add(this.onDragStop, this);\n\t\t}\n\t},\n\n\tonDragStart: function (sprite) {\n\t\tconsole.log(this.circle.input.pointerDragged());\n\t\tsprite.frame = 2; // make circle grey whilst being dragged\n\n\t\t//        if (this.justAClick(sprite)) {return;} // if the user just clicked (no drag), do nothing\n\n\t\t// check if this is the initial move or subsequent move for circle\n\t\tif (sprite.moved) {\n\t\t\t// already moved. Capture current coordinates in a temp variable, tempCoord.\n\t\t\tthis.tempXY = { x: sprite.x, y: sprite.y };\n\t\t\tthis.tempCoord = this.getCoord(sprite);\n\t\t\t// debug\n\t\t\t//            console.log('already moved, on an occupied box ' + this.tempCoord.x + this.tempCoord.y + 'gridMatrix is ' + this.gridMatrix[this.tempCoord.y][this.tempCoord.x]);\n\t\t\t// reset the status in the grid to zero\n\t\t\tthis.gridMatrix[this.tempCoord.y][this.tempCoord.x] = 0; // x is column, y is row\n\t\t\t// console.log('gridMatrix set to zero ' + this.gridMatrix[this.tempCoord.y][this.tempCoord.x]);\n\n\t\t\treturn; // exit\n\t\t}\n\t\telse if (!sprite.moved) {\n\t\t\t// moved == false, Therefore it is the initial movement\n\t\t\t//           console.log('initial move');\n\t\t\t//           sprite.moved = true; // first move done\n\t\t\t// change sprite colour in spritesheet\n\t\t} else {\n\t\t\tthrow new Error(console.log('something went wrong, ' + sprite.frame));\n\t\t}\n\n\t\t// debug\n\t\tthis.result = 'dragging ' + sprite.key;\n\t},\n\n\tonDragStop: function (sprite) {\n\t\tconsole.log(this.circle.input.pointerDragged());\n\t\tconsole.log('dragStop event...')\n\t\t/*\n\t\t// First, we check for overlap with the whole grid frame and reset circle if out of bounds\n\t\tif (!Phaser.Rectangle.intersects(sprite.getBounds(), this.frame)) {\n\t\t\t\tthis.resetCircle(sprite);\n\t\t\t\tconsole.log('out of bounds, resetting circle');\n\t\t\t\treturn; // exit\n\t\t}\n\t\t*/\n\t\t// Second, we find the coordinates of the current location (within the frame)\n\t\tvar coord = this.getCoord(sprite);\n\t\t// debug\n\t\tconsole.log(coord);\n\t\tthis.seeGrid();\n\n\t\t// Third, we check if this is the location is occupied\n\t\tthis.occupied = this.gridMatrix[coord.y][coord.x] === 1;\n\n\t\tif (!this.occupied && !sprite.moved) {\n\t\t\t// Not occupied AND initial movement, therefore occupy location\n\t\t\tthis.gridMatrix[coord.y][coord.x] = 1; // occupy location\n\t\t\tsprite.moved = true; // mark circle as moved\n\t\t\tthis.refreshStats(-1); // reduce counter as this is initial movement of circle\n\t\t\tthis.snapToGrid(sprite); // snap to grid\n\t\t\tsprite.frame = 1; // change to blue colour, resting state\n\t\t\tconsole.log('Not OCC - 1st Move');\n\t\t}\n\t\telse if (!this.occupied && sprite.moved) {\n\t\t\t// Not occupied AND subsequent move (new location OR just up and down movement, i.e. same location)\n\t\t\t// Clear previous location first (IMPORTANT, if up and down movement)\n\t\t\tthis.gridMatrix[this.tempCoord.y][this.tempCoord.x] = 0; //reset old location\n\t\t\tthis.gridMatrix[coord.y][coord.x] = 1; // occupy location (either same or new)\n\t\t\tthis.snapToGrid(sprite);\n\t\t\tsprite.frame = 1; // change to blue colour, resting state\n\t\t\tconsole.log('Not OCC - later Move');\n\t\t}\n\t\telse if (this.occupied && !sprite.moved) {\n\t\t\t// Occupied AND this is the initial movement of this circle\n\t\t\t// reset circle\n\t\t\tthis.resetCircle(sprite);\n\t\t\tconsole.log(' OCC - 1st Move');\n\t\t}\n\t\telse if (this.occupied && sprite.moved) {\n\t\t\t// Occupied AND circle is being moved from previous location\n\t\t\t// move circle back to previous location and occupy it on the grid\n\t\t\tsprite.x = this.tempXY.x;\n\t\t\tsprite.y = this.tempXY.y;\n\t\t\tthis.snapToGrid(sprite);\n\t\t\tthis.gridMatrix[this.tempCoord.y][this.tempCoord.x] = 1; // occupy location (either same or new)\n\t\t\tsprite.frame = 1; // change to blue colour, resting state\n\t\t\tconsole.log(' OCC - later Move');\n\t\t}\n\t\tthis.seeGrid(); // let's check the grid now\n\n\t\t/* check if there is already a circle on those coordinates\n\t\tif (this.gridMatrix[coord.y][coord.x] === 1 ) { //x is column, y is row\n\t\t\t\tthis.resetCircle(sprite);\n\t\t\t\tthis.seeGrid();\n\t\t\t\treturn;\n\t\t} else if (sprite.moved) { // check if this is the initial move, if not, don't change counter\n\t\t\t\t// mark location of the circle in the grid matrix\n\t\t\t\tthis.gridMatrix[coord.y][coord.x] = 1;\n\t\t\t\tthis.seeGrid();\n\t\t} else {\n\t\t\t\t// initial move to an empty place - mark location of the circle in the grid matrix\n\t\t\t\tsprite.moved = true; // first move done\n\t\t\t\tthis.gridMatrix[coord.y][coord.x] = 1;\n\t\t\t\tthis.seeGrid();\n\t\t\t\tthis.refreshStats(1);\n*/\n\n\t\tthis.result = 'dropped ' + sprite.key + sprite.position;\n\t\tthis.result = sprite.key + \" dropped at x:\" + sprite.x + \" y: \" + sprite.y;\n\t},\n\n\tgetCoord: function (sprite) {\n\t\t// find the coordinates of the sprite, as we now know the coordinates are within the frame\n\t\tvar getCoord = { x: 0, y: 0 };\n\t\tgetCoord.x = Math.floor((sprite.position.x - this.GRID_START_X) / this.BLOCK_SIZE);\n\t\tgetCoord.y = Math.floor((sprite.position.y - this.GRID_START_Y) / this.BLOCK_SIZE);\n\t\tconsole.log(getCoord.x + ', ' + getCoord.y);\n\t\treturn getCoord;\n\n\t\t/*\n\t\t\t\t\t\t// find the coordinates of the sprite, as we now know the coordinates are within the frame\n\t\t\t\t\t\tvar coord = {x: 0, y: 0};\n\t\t\t\t\t\tconsole.log(sprite.x + ', ' + sprite.y);\n\t\t\t\t\t\tcoord.x = (sprite.position.x - (sprite.position.x % this.BLOCK_SIZE)) / this.BLOCK_SIZE - 1; // minus 1, as 0-7\n\t\t\t\t\t\tcoord.y = (sprite.position.y - (sprite.position.y % this.BLOCK_SIZE)) / this.BLOCK_SIZE - 1;\n\t\t\t\t\t\treturn coord;\n\t\t*/\n\t},\n\n\tresetCircle: function (sprite) {\n\t\t// move sprite back to the middle change to original sprite frame\n\t\tsprite.position.x = this.frame.centerX;\n\t\tsprite.position.y = this.frame.centerY;\n\t\tsprite.frame = 0;\n\t},\n\n\trefreshStats: function (counter) {\n\t\t// reduce counter, if not already 0\n\t\tif (this.circlesLeft > 0) {\n\t\t\tthis.circlesLeft += counter;\n\t\t}\n\t\tthis.circleScore.text = this.circlesLeft;\n\t},\n\n\tseeGrid: function () {\n\t\tvar gridString = '';\n\n\t\tfor (var i = 0; i < this.NUM_ROWS; i++) {\n\t\t\tgridString += '\\n';\n\t\t\tfor (var j = 0; j < this.NUM_COLS; j++) {\n\t\t\t\tgridString += ' ' + this.gridMatrix[i][j];\n\t\t\t}\n\t\t}\n\t\tconst headers = {\n\t\t\t'Access-Control-Allow-Origin': '*',\n\t\t\t'Content-Type': 'application/json',\n\t\t}\n\t\t// if (!this.circlesLeft) {\n\t\t// \tconst data = JSON.stringify(this.gridMatrix);\n\t\t// \tconsole.log('sending results');\n\t\t// \taxios.post('http://127.0.0.1:3000/result', data, { headers: headers })\n\t\t// \t\t.then((res, err) => {\n\t\t// \t\t\tif (err) return console.error(err);\n\t\t// \t\t\tconsole.log(res);\n\t\t// \t\t})\n\t\t// }\n\t},\n\tsnapToGrid: function (sprite) {\n\t\tfor (var i = 0; i < this.rect.length; i++) {\n\t\t\tif (this.rect[i].contains(sprite.x, sprite.y)) {\n\t\t\t\tsprite.centerX = this.rect[i].centerX;\n\t\t\t\tsprite.centerY = this.rect[i].centerY;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t},\n\tjustAClick: function (sprite) {\n\t\tvar distanceFromLastUp = Phaser.Math.distance(game.input.activePointer.positionDown.x,\n\t\t\tgame.input.activePointer.positionDown.y, game.input.activePointer.x, game.input.activePointer.y);\n\t\treturn distanceFromLastUp != 0;\n\t},\n\t/*\n\t// Debugging...\n\trender: function () {\n\t\t\t// input some debug info on the screen\n\t\t\tgame.debug.inputInfo(400, 200, '#000');\n\t\t\tgame.debug.text(this.result, 10, 20, '#000');\n\t\t\tgame.debug.timer(this.result, 400, 300, '#000');\n\t\t\tgame.debug.rectangle(this.frame, '#ffff00', false);\n\n\t}\n*/\n};\n"]}